.global _start

_start:
	
	MOV V2, #0 //rotation offset
	MOV V3, #1 //reversal bit (1 for left, 0 for right rotation)
    MOV V4, #0 // LED Counter
    MOV V5, #-1     //to force message load first loop

    
    MOV A1, #0x3F           
    BL HEX_clear_ASM
    MOV A1, #0              
    BL write_LEDs_ASM
    BL PB_clear_edgecp_ASM  


main_loop:
    
    BL read_slider_switches_ASM 

    CMP A1, V5
    BEQ check_buttons       

    
    MOV V5, A1             
    MOV V4, #0             
	MOV V2, #0
	
	

    MOV V1, #0 
    
    CMP A1, #0x00
    LDREQ V1, =MSG_C0FFEE
    BEQ check_buttons

    CMP A1, #0x01
    LDREQ V1, =MSG_CAFE5
    BEQ check_buttons

    CMP A1, #0x02
    LDREQ V1, =MSG_CAb5
    BEQ check_buttons

    CMP A1, #0x04
    LDREQ V1, =MSG_ACE
	BEQ check_buttons

    
    MOV V1, #0


check_buttons:
   

	
	CMP V1, #0
    BEQ draw_outputs

    MOV A1, #0x04          
    BL PB_edgecp_is_pressed_ASM
    CMP A1, #1
    EOREQ V3, V3, #1

    MOV A1, #0x08           
    BL PB_edgecp_is_pressed_ASM
    CMP A1, #1
    BNE draw_outputs

    
    CMP V3, #0
    BEQ do_decrement        
    
    
	ADD V2, V2, #1          
	CMP V2, #6          
    MOVEQ V2, #0
    B rotation_logic_done   

do_decrement:
    SUB V2, V2, #1         
    
    CMP V2, #-6             
    MOVEQ V2, #0           

rotation_logic_done:

	ADD V4, V4, #1

draw_outputs:
    BL PB_clear_edgecp_ASM

    CMP V1, #0
    BEQ clear_screen
    
    MOV A1, V1
	MOV A2, V2
    BL DISPLAY_MESSAGE_ASM
    B draw_leds

clear_screen:
    MOV A1, #0x3F
    BL HEX_clear_ASM

draw_leds:

	LDR R0, =1023
    CMP V4, R0
    BHI set_max_leds
    MOV A1, V4
    B write_led_value

set_max_leds:
    LDR A1, =0x3FF
    
write_led_value:
    BL write_LEDs_ASM
    
    B main_loop


DISPLAY_MESSAGE_ASM:
    PUSH {V1-V6, LR}     
    MOV V1, A1            
    MOV V2, #0            
    MOV V5, A2           
    MOV V6, #6            
display_loop_offset:
    LDRB V3, [V1, V2]    
    CMP V3, #255
    BEQ clear_this_digit

    MOV V4, #5
    SUB V4, V4, V2
    ADD V4, V4, V5        
    
wrap_left:
    CMP V4, #0
    BGE wrap_right
    ADD V4, V4, #6        
    B wrap_done
wrap_right:
    CMP V4, #6
    BLT wrap_done
    SUB V4, V4, #6        
wrap_done:

    MOV A1, #1
    LSL A1, A1, V4

    MOV A2, V3
    BL HEX_write_ASM
    B next_iter

clear_this_digit:
    
	MOV V4, #5
    SUB V4, V4, V2
    ADD V4, V4, V5

wrap_left_clr:
    CMP V4, #0
    BGE wrap_right_clr
    ADD V4, V4, #6
    
	B wrap_done_clr
wrap_right_clr:
    CMP V4, #6
    BLT wrap_done_clr
   
    SUB V4, V4, #6
wrap_done_clr:
    
	MOV A1, #1
    LSL A1, A1, V4
    BL HEX_clear_ASM

next_iter:
    
	ADD V2, V2, #1
    CMP V2, #6
    BLT display_loop_offset

    POP {V1-V6, PC}








stop:
    b stop


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	







	

.data
MSG_C0FFEE: .byte 12, 0, 15, 15, 14, 14//,255
MSG_CAFE5:  .byte 12, 10, 15, 14, 5, 255
MSG_CAb5:   .byte 12, 10, 11, 5, 255, 255
MSG_ACE:    .byte 10, 12, 14, 255, 255, 255

.text




.equ HEX_BASE_ADDR, 0xFF200020
.equ HEX_BASE_ADDR_4_5, 0xFF200030
.equ PB_DATA_ADDR, 0xFF200050
.equ PB_EDGECP_ADDR, 0xFF20005C
.equ PB_INTMASK_ADDR, 0xFF200058
.equ SW_ADDR, 0xFF200040
.equ LED_ADDR, 0xFF200000

HEX_CODES:
	.byte 0b00111111, 0b00000110, 0b01011011, 0b01001111 // 0-3
	.byte 0b01100110, 0b01101101, 0b01111101, 0b00000111 // 4-7
 	.byte 0b01111111, 0b01101111, 0b01110111, 0b01111100 // 8-b
	.byte 0b00111001, 0b01011110, 0b01111001, 0b01110001 // C-F













read_PB_data_ASM:
	LDR A2, =PB_DATA_ADDR
	LDR A1, [A2]
	BX LR





PB_data_is_pressed_ASM:
	LDR A2, =PB_DATA_ADDR
	LDR A3, [A2] 
	
	ANDS A3, A3, A1
	BNE data_pressed

data_not_pressed:
	MOV A1, #0
	B done

data_pressed:
	MOV A1, #1

done:	
	BX LR 




read_PB_edgecp_ASM:
	LDR A2, =PB_EDGECP_ADDR
	LDR A1, [A2]
	AND A1, A1, #0xF
	BX LR





PB_edgecp_is_pressed_ASM:

	LDR A2, =PB_EDGECP_ADDR
    LDR A3, [A2]
	  
	ANDS A3, A3, A1
	BNE edge_pressed

edge_not_pressed:
	MOV A1, #0
	B edge_done

edge_pressed:
	MOV A1, #1


edge_done:	
	BX LR

PB_clear_edgecp_ASM:
	LDR A2, =PB_EDGECP_ADDR
	LDR A1, [A2]
	STR A1, [A2]
	BX LR


enable_PB_INT_ASM:
	LDR A2, =PB_INTMASK_ADDR
	LDR A3, [A2]
	ORR A3, A3, A1
	STR A3, [A2]
	BX LR




disable_PB_INT_ASM:
	LDR A2, =PB_INTMASK_ADDR
	LDR A3, [A2]
	BIC A3, A3, A1
	STR A3, [A2]
	BX LR


HEX_clear_ASM:
	PUSH {V1,V2,LR} 
	MOV V1, #0 //i=0

loop_clr:
	MOV A3, #1
	LSL A3, A3, V1
	ANDS A4, A1, A3
	BEQ skip_clearing // if not on skip clearing
	
	CMP V1, #4
	BLT clr_hex0_3

clr_hex4_5: // handle HEX4 and HEX5
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_clear_store

clr_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1


do_clear_store:
	MOV A2, #0
	STRB A2, [A3]
skip_clearing:
	ADD V1, V1, #1
	CMP V1,#6
	BLT loop_clr
	POP {V1,V2,PC}  




HEX_flood_ASM:
	PUSH {V1,V2,LR} 
	MOV V1, #0 //i

loop_fld:
	MOV A3, #1
	LSL A3, A3, V1
	ANDS A4, A1, A3
	BEQ skip_flooding
	
	CMP V1, #4
	BLT fld_hex0_3

fld_hex4_5:
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_flood_store

fld_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1
do_flood_store:
	MOV A2, #0xFF
	STRB A2, [A3]
skip_flooding:
	ADD V1, V1, #1
	CMP V1, #6
	BLT loop_fld
	
	POP {V1,V2,PC}





HEX_write_ASM:
	PUSH {V1,V2,LR} 
	LDR A3, =HEX_CODES
	
	
	ADD A3, A3, A2
	LDRB A4, [A3]
	MOV V1, #0 //i


loop_write:
	MOV A3, #1
	LSL A3, A3, V1
	TST A1, A3
	BEQ skip_writing 
	CMP V1, #4
	BLT write_hex0_3

write_hex4_5:
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_write_store


write_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1
do_write_store:
	STRB A4, [A3]

skip_writing:
	ADD V1, V1, #1
	CMP V1, #6
	BLT loop_write
	POP {V1,V2, PC}









read_slider_switches_ASM:
    LDR A2, =SW_ADDR
    LDR A1, [A2]
    BX LR
write_LEDs_ASM:
    LDR A2, =LED_ADDR
    STR A1, [A2]
    BX LR
