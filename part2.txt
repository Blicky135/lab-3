
MSG_C0FFEE: .byte 12, 0, 15, 15, 14, 14
MSG_CAFE5:  .byte 12, 10, 15, 14, 5, 255
MSG_CAb5:   .byte 12, 10, 11, 5, 255, 255
MSG_ACE:    .byte 10, 12, 14, 255, 255, 255

.equ HEX_BASE_ADDR, 0xFF200020
.equ HEX_BASE_ADDR_4_5, 0xFF200030
.equ PB_DATA_ADDR, 0xFF200050
.equ PB_EDGECP_ADDR, 0xFF20005C
.equ PB_INTMASK_ADDR, 0xFF200058
.equ SW_ADDR, 0xFF200040
.equ LED_ADDR, 0xFF200000


.equ ARM_TIMER_BASE, 0xFFFEC600         // Base address for the timer hardware
.equ ARM_TIMER_LOAD_OFFSET, 0x0        // Offset for the Load Value register
.equ ARM_TIMER_CONTROL_OFFSET, 0x8     // Offset for the Control/Configuration register
.equ ARM_TIMER_INTERRUPT_OFFSET, 0xC  // Offset for the Interrupt Status ("F" bit) 



HEX_CODES:
	.byte 0b00111111, 0b00000110, 0b01011011, 0b01001111 // 0-3
	.byte 0b01100110, 0b01101101, 0b01111101, 0b00000111 // 4-7
	.byte 0b01111111, 0b01101111, 0b01110111, 0b01111100 // 8-b
	.byte 0b00111001, 0b01011110, 0b01111001, 0b01110001 // C-F


.section .vectors, "ax"
B _start // reset vector
B SERVICE_UND // undefined instruction vector
B SERVICE_SVC // software interrupt vector
B SERVICE_ABT_INST // aborted prefetch vector
B SERVICE_ABT_DATA // aborted data vector
.word 0 // unused vector
B SERVICE_IRQ // IRQ interrupt vector

.text
.global _start
_start:
/* Set up stack pointers for IRQ and SVC processor modes */
	MOV R1, #0b11010010 // interrupts masked, MODE = IRQ
	MSR CPSR_c, R1 // change to IRQ mode
	LDR SP, =0xFFFFFFFF - 3 // set IRQ stack to A9 on-chip memory
	/* Change to SVC (supervisor) mode with interrupts disabled */
	MOV R1, #0b11010011 // interrupts masked, MODE = SVC
	MSR CPSR, R1 // change to supervisor mode
	LDR SP, =0x3FFFFFFF - 3 // set SVC stack to top of DDR3 memory
	BL CONFIG_GIC // configure the ARM GIC
	// NOTE: write to the pushbutton KEY interrupt mask register
	// Or, you can call enable_PB_INT_ASM subroutine from previous task
	// to enable interrupt for ARM A9 private timer,
	// use ARM_TIM_config_ASM subroutine
	LDR R0, =0xFF200050 // pushbutton KEY base address
	MOV R1, #0xF // set interrupt mask bits
	STR R1, [R0, #0x8] // interrupt mask register (base + 8)
	// enable IRQ interrupts in the processor
	MOV R0, #0b01010011 // IRQ unmasked, MODE = SVC
	MSR CPSR_c, R0
IDLE:
	B IDLE // This is where you write your main program task(s)


CONFIG_GIC:
	PUSH {LR}
/* To configure the FPGA KEYS interrupt (ID 73):
* 1. set the target to cpu0 in the ICDIPTRn register
* 2. enable the interrupt in the ICDISERn register */
/* CONFIG_INTERRUPT (int_ID (R0), CPU_target (R1)); */
/* NOTE: you can configure different interrupts
	by passing their IDs to R0 and repeating the next 3 lines */
	MOV R0, #73 // KEY port (Interrupt ID = 73)
	MOV R1, #1 // this field is a bit-mask; bit 0 targets cpu0
	BL CONFIG_INTERRUPT
/* configure the GIC CPU Interface */
	LDR R0, =0xFFFEC100 // base address of CPU Interface
/* Set Interrupt Priority Mask Register (ICCPMR) */
	LDR R1, =0xFFFF // enable interrupts of all priorities levels
	STR R1, [R0, #0x04]
/* Set the enable bit in the CPU Interface Control Register (ICCICR).
* This allows interrupts to be forwarded to the CPU(s) */
	MOV R1, #1
	STR R1, [R0]
/* Set the enable bit in the Distributor Control Register (ICDDCR).
* This enables forwarding of interrupts to the CPU Interface(s) */
	LDR R0, =0xFFFED000
	STR R1, [R0]
	POP {PC}


/*
* Configure registers in the GIC for an individual Interrupt ID
* We configure only the Interrupt Set Enable Registers (ICDISERn) and
* Interrupt Processor Target Registers (ICDIPTRn). The default (reset)
* values are used for other registers in the GIC
* Arguments: R0 = Interrupt ID, N
* R1 = CPU target
*/
CONFIG_INTERRUPT:
	PUSH {R4-R5, LR}
/* Configure Interrupt Set-Enable Registers (ICDISERn).
* reg_offset = (integer_div(N / 32) * 4
* value = 1 << (N mod 32) */
	LSR R4, R0, #3 // calculate reg_offset
	BIC R4, R4, #3 // R4 = reg_offset
	LDR R2, =0xFFFED100
	ADD R4, R2, R4 // R4 = address of ICDISER
	AND R2, R0, #0x1F // N mod 32
	MOV R5, #1 // enable
	LSL R2, R5, R2 // R2 = value
/* Using the register address in R4 and the value in R2 set the
* correct bit in the GIC register */
	LDR R3, [R4] // read current register value
	ORR R3, R3, R2 // set the enable bit
	STR R3, [R4] // store the new register value
/* Configure Interrupt Processor Targets Register (ICDIPTRn)
* reg_offset = integer_div(N / 4) * 4
* index = N mod 4 */
	BIC R4, R0, #3 // R4 = reg_offset
	LDR R2, =0xFFFED800
	ADD R4, R2, R4 // R4 = word address of ICDIPTR
	AND R2, R0, #0x3 // N mod 4
	ADD R4, R2, R4 // R4 = byte address in ICDIPTR
/* Using register address in R4 and the value in R2 write to
* (only) the appropriate byte */
	STRB R1, [R4]
	POP {R4-R5, PC}


	
	
/*--- Undefined instructions --------------------------------------*/
SERVICE_UND:
	B SERVICE_UND
/*--- Software interrupts ----------------------------------------*/
SERVICE_SVC:
	B SERVICE_SVC
/*--- Aborted data reads ------------------------------------------*/
SERVICE_ABT_DATA:
	B SERVICE_ABT_DATA
/*--- Aborted instruction fetch -----------------------------------*/
SERVICE_ABT_INST:
	B SERVICE_ABT_INST
/*--- IRQ ---------------------------------------------------------*/
SERVICE_IRQ:
	PUSH {R0-R7, LR}
/* Read the ICCIAR from the CPU Interface */
	LDR R4, =0xFFFEC100
	LDR R5, [R4, #0x0C] // read from ICCIAR
/* NOTE: Check which interrupt has occurred (check interrupt IDs)
Then call the corresponding ISR
If the ID is not recognized, branch to UNEXPECTED
See the assembly example provided in the DE1-SoC Computer Manual
on page 46 */
Pushbutton_check:
	CMP R5, #73
UNEXPECTED:
	BNE UNEXPECTED // if not recognized, stop here
	BL KEY_ISR
EXIT_IRQ:
/* Write to the End of Interrupt Register (ICCEOIR) */
	STR R5, [R4, #0x10] // write to ICCEOIR
	POP {R0-R7, LR}
	SUBS PC, LR, #4
/*--- FIQ ---------------------------------------------------------*/
SERVICE_FIQ:
	B SERVICE_FIQ 
   
   
   
KEY_ISR:
	LDR R0, =0xFF200050 // base address of pushbutton KEY port
	LDR R1, [R0, #0xC] // read edge capture register
	MOV R2, #0xF
	STR R2, [R0, #0xC] // clear the interrupt
	LDR R0, =0xFF200020 // base address of HEX display
CHECK_KEY0:
	MOV R3, #0x1
	ANDS R3, R3, R1 // check for KEY0
	BEQ CHECK_KEY1
	MOV R2, #0b00111111
	STR R2, [R0] // display "0"
	B END_KEY_ISR
CHECK_KEY1:
	MOV R3, #0x2
	ANDS R3, R3, R1 // check for KEY1
	BEQ CHECK_KEY2
	MOV R2, #0b00000110
	STR R2, [R0] // display "1"
	B END_KEY_ISR
CHECK_KEY2:
	MOV R3, #0x4
	ANDS R3, R3, R1 // check for KEY2
	BEQ IS_KEY3
	MOV R2, #0b01011011
	STR R2, [R0] // display "2"
	B END_KEY_ISR
IS_KEY3:
	MOV R2, #0b01001111
	STR R2, [R0] // display "3"
END_KEY_ISR:
	BX LR  
   
   
   
   
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   






//part 2:




ARM_TIM_config_ASM:
    LDR A3, =ARM_TIMER_BASE     // Load the base memory address of the timer hardware into A3.

    // Write the countdown value to the Load Register
    STR A1, [A3, #ARM_TIMER_LOAD_OFFSET] // Store the value from A1 into the memory location
                                         // at [base address + 0]. This sets the starting count.

    // Write the configuration bits to the Control Register
    STR A2, [A3, #ARM_TIMER_CONTROL_OFFSET] // Store the value from A2 into the memory location
                                            // at [base address + 8]. This turns the timer on.
    
    BX LR                       // Return from the subroutine.




ARM_TIM_read_INT_ASM:
    LDR A2, =ARM_TIMER_BASE     // Load the base memory address of the timer hardware into A2.

    // Read the "F" bit from the Interrupt Status Register
    LDR A1, [A2, #ARM_TIMER_INTERRUPT_OFFSET] // Load the value from the memory location
                                              // at [base address + 12] into A1. This hardware
                                              // register will contain either 0 or 1.
    
    BX LR                       // Return. A1 now holds the "F" bit's value.




ARM_TIM_clear_INT_ASM:
    LDR A2, =ARM_TIMER_BASE     // Load the base memory address of the timer hardware into A2.
    MOV A1, #1                  // Put the number 1 into register A1.

    // Write a 1 to the Interrupt Status Register to clear the "F" bit
    STR A1, [A2, #ARM_TIMER_INTERRUPT_OFFSET] // Store the value 1 into the memory location
                                              // at [base address + 12]. The hardware sees this
                                              // and resets its internal flag to 0.
                                              
    BX LR                       // Return from the subroutine.































read_PB_data_ASM:
	LDR A2, =PB_DATA_ADDR
	LDR A1, [A2]
	BX LR





PB_data_is_pressed_ASM:
	LDR A2, =PB_DATA_ADDR
	LDR A3, [A2] 
	
	ANDS A3, A3, A1
	BNE data_pressed

data_not_pressed:
	MOV A1, #0
	B done

data_pressed:
	MOV A1, #1

done:	
	BX LR 




read_PB_edgecp_ASM:
	LDR A2, =PB_EDGECP_ADDR
	LDR A1, [A2]
	AND A1, A1, #0xF
	BX LR





PB_edgecp_is_pressed_ASM:

	LDR A2, =PB_EDGECP_ADDR
    LDR A3, [A2]
	  
	ANDS A3, A3, A1
	BNE edge_pressed

edge_not_pressed:
	MOV A1, #0
	B edge_done

edge_pressed:
	MOV A1, #1


edge_done:	
	BX LR

PB_clear_edgecp_ASM:
	LDR A2, =PB_EDGECP_ADDR
	LDR A1, [A2]
	STR A1, [A2]
	BX LR


enable_PB_INT_ASM:
	LDR A2, =PB_INTMASK_ADDR
	LDR A3, [A2]
	ORR A3, A3, A1
	STR A3, [A2]
	BX LR




disable_PB_INT_ASM:
	LDR A2, =PB_INTMASK_ADDR
	LDR A3, [A2]
	BIC A3, A3, A1
	STR A3, [A2]
	BX LR


HEX_clear_ASM:
	PUSH {V1,V2,LR} 
	MOV V1, #0 //i=0

loop_clr:
	MOV A3, #1
	LSL A3, A3, V1
	ANDS A4, A1, A3
	BEQ skip_clearing // if not on skip clearing
	
	CMP V1, #4
	BLT clr_hex0_3

clr_hex4_5: // handle HEX4 and HEX5
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_clear_store

clr_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1


do_clear_store:
	MOV A2, #0
	STRB A2, [A3]
skip_clearing:
	ADD V1, V1, #1
	CMP V1,#6
	BLT loop_clr
	POP {V1,V2,PC}  




HEX_flood_ASM:
	PUSH {V1,V2,LR} 
	MOV V1, #0 //i

loop_fld:
	MOV A3, #1
	LSL A3, A3, V1
	ANDS A4, A1, A3
	BEQ skip_flooding
	
	CMP V1, #4
	BLT fld_hex0_3

fld_hex4_5:
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_flood_store

fld_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1
do_flood_store:
	MOV A2, #0xFF
	STRB A2, [A3]
skip_flooding:
	ADD V1, V1, #1
	CMP V1, #6
	BLT loop_fld
	
	POP {V1,V2,PC}





HEX_write_ASM:
	PUSH {V1,V2,LR} 
	LDR A3, =HEX_CODES
	
	
	ADD A3, A3, A2
	LDRB A4, [A3]
	MOV V1, #0 //i


loop_write:
	MOV A3, #1
	LSL A3, A3, V1
	TST A1, A3
	BEQ skip_writing 
	CMP V1, #4
	BLT write_hex0_3

write_hex4_5:
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_write_store


write_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1
do_write_store:
	STRB A4, [A3]

skip_writing:
	ADD V1, V1, #1
	CMP V1, #6
	BLT loop_write
	POP {V1,V2, PC}









read_slider_switches_ASM:
    LDR A2, =SW_ADDR
    LDR A1, [A2]
    BX LR
write_LEDs_ASM:
    LDR A2, =LED_ADDR
    STR A1, [A2]
    BX LR
