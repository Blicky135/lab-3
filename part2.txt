.equ HEX_BASE_ADDR, 0xFF200020
.equ HEX_BASE_ADDR_4_5, 0xFF200030
.equ PB_DATA_ADDR, 0xFF200050
.equ PB_EDGECP_ADDR, 0xFF20005C
.equ PB_INTMASK_ADDR, 0xFF200058
.equ SW_ADDR, 0xFF200040
.equ LED_ADDR, 0xFF200000


.equ ARM_TIMER_BASE, 0xFFFEC600         // Base address for the timer hardware
.equ ARM_TIMER_LOAD_OFFSET, 0x0        // Offset for the Load Value register
.equ ARM_TIMER_CONTROL_OFFSET, 0x8     // Offset for the Control/Configuration register
.equ ARM_TIMER_INTERRUPT_OFFSET, 0xC  // Offset for the Interrupt Status ("F" bit) 

.global _start
.data

// --- State Variables (These are pointers/words, so they should be aligned) ---
.align 2
current_message_ptr:
    .word MSG_C0FFEE
previous_switch_state:
    .word 0x0
display_offset:
    .word 0
direction:
    .word 1
speed_index:
    .word 2
is_paused:
    .word 0

// --- Interrupt Flags (Also words) ---
.align 2
PB_int_flag:
    .word 0x0
tim_int_flag:
    .word 0x0

// --- Messages (These are byte arrays, they don't need alignment) ---
MSG_C0FFEE:     .byte 12, 0, 15, 15, 14, 14, 255
MSG_CAFE5:      .byte 12, 10, 15, 14, 5, 255
MSG_CAb5:       .byte 12, 10, 11, 5, 255, 255
MSG_ACE:        .byte 10, 12, 14, 255, 255, 255
MSG_70Ad:       .byte 7, 0, 10, 13, 5, 7, 0, 0, 1, 5, 255
MSG_CAFEbEEF:   .byte 12, 10, 15, 14, 11, 14, 14, 15, 12, 0, 15, 15, 14, 14, 255
BLANK_MSG:      .byte 255

// --- Lookup Tables (These are .word arrays, they MUST be aligned) ---
.align 2
SPEED_TABLE:
    .word 200000000, 100000000, 50000000, 25000000, 12500000
.align 2
LED_TABLE:
    .word 0b0000000011, 0b0000001111, 0b0000111111, 0b0011111111, 0b1111111111

// --- 7-Segment HEX Codes (Byte array, no alignment needed) ---
HEX_CODES:
	.byte 0b00111111, 0b00000110, 0b01011011, 0b01001111 // 0-3
	.byte 0b01100110, 0b01101101, 0b01111101, 0b00000111 // 4-7
	.byte 0b01111111, 0b01101111, 0b01110111, 0b01111100 // 8-b
	.byte 0b00111001, 0b01011110, 0b01111001, 0b01110001 // C-F
	.byte 0x00 // Blank character for padding

.section .vectors, "ax"
B _start // reset vector
B SERVICE_UND // undefined instruction vector
B SERVICE_SVC // software interrupt vector
B SERVICE_ABT_INST // aborted prefetch vector
B SERVICE_ABT_DATA // aborted data vector
.word 0 // unused vector
B SERVICE_IRQ // IRQ interrupt vector

.text
.global _start

ARM_TIM_ISR:
    PUSH {R2, R3, LR}               // Save registers
    
    LDR R2, =tim_int_flag       // Load address of our timer flag
    MOV R3, #1
    STR R3, [R2]                // Set the timer flag to 1

    BL ARM_TIM_clear_INT_ASM    // Call your driver to clear the timer's interrupt

    POP {R2, R3, PC}                // Restore registers

ARM_TIM_config_ASM:
    LDR A3, =ARM_TIMER_BASE     // Load the base memory address of the timer hardware into A3.

    // Write the countdown value to the Load Register
    STR A1, [A3, #ARM_TIMER_LOAD_OFFSET] // Store the value from A1 into the memory location
                                         // at [base address + 0]. This sets the starting count.

    // Write the configuration bits to the Control Register
    STR A2, [A3, #ARM_TIMER_CONTROL_OFFSET] // Store the value from A2 into the memory location
                                            // at [base address + 8]. This turns the timer on.
    
    BX LR                       // Return from the subroutine.




ARM_TIM_read_INT_ASM:
    LDR A2, =ARM_TIMER_BASE     // Load the base memory address of the timer hardware into A2.

    // Read the "F" bit from the Interrupt Status Register
    LDR A1, [A2, #ARM_TIMER_INTERRUPT_OFFSET] // Load the value from the memory location
                                              // at [base address + 12] into A1. This hardware
                                              // register will contain either 0 or 1.
    
    BX LR                       // Return. A1 now holds the "F" bit's value.




ARM_TIM_clear_INT_ASM:
    LDR A2, =ARM_TIMER_BASE     // Load the base memory address of the timer hardware into A2.
    MOV A1, #1                  // Put the number 1 into register A1.

    // Write a 1 to the Interrupt Status Register to clear the "F" bit
    STR A1, [A2, #ARM_TIMER_INTERRUPT_OFFSET] // Store the value 1 into the memory location
                                              // at [base address + 12]. The hardware sees this
                                              // and resets its internal flag to 0.
                                              
    BX LR                       // Return from the subroutine.































read_PB_data_ASM:
	LDR A2, =PB_DATA_ADDR
	LDR A1, [A2]
	BX LR





PB_data_is_pressed_ASM:
	LDR A2, =PB_DATA_ADDR
	LDR A3, [A2] 
	
	ANDS A3, A3, A1
	BNE data_pressed

data_not_pressed:
	MOV A1, #0
	B done

data_pressed:
	MOV A1, #1

done:	
	BX LR 




read_PB_edgecp_ASM:
	LDR A2, =PB_EDGECP_ADDR
	LDR A1, [A2]
	AND A1, A1, #0xF
	BX LR





PB_edgecp_is_pressed_ASM:

	LDR A2, =PB_EDGECP_ADDR
    LDR A3, [A2]
	  
	ANDS A3, A3, A1
	BNE edge_pressed

edge_not_pressed:
	MOV A1, #0
	B edge_done

edge_pressed:
	MOV A1, #1


edge_done:	
	BX LR

PB_clear_edgecp_ASM:
	LDR A2, =PB_EDGECP_ADDR
	LDR A1, [A2]
	STR A1, [A2]
	BX LR


enable_PB_INT_ASM:
	LDR A2, =PB_INTMASK_ADDR
	LDR A3, [A2]
	ORR A3, A3, A1
	STR A3, [A2]
	BX LR




disable_PB_INT_ASM:
	LDR A2, =PB_INTMASK_ADDR
	LDR A3, [A2]
	BIC A3, A3, A1
	STR A3, [A2]
	BX LR


HEX_clear_ASM:
	PUSH {V1,V2,LR} 
	MOV V1, #0 //i=0

loop_clr:
	MOV A3, #1
	LSL A3, A3, V1
	ANDS A4, A1, A3
	BEQ skip_clearing // if not on skip clearing
	
	CMP V1, #4
	BLT clr_hex0_3

clr_hex4_5: // handle HEX4 and HEX5
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_clear_store

clr_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1


do_clear_store:
	MOV A2, #0
	STRB A2, [A3]
skip_clearing:
	ADD V1, V1, #1
	CMP V1,#6
	BLT loop_clr
	POP {V1,V2,PC}  




HEX_flood_ASM:
	PUSH {V1,V2,LR} 
	MOV V1, #0 //i

loop_fld:
	MOV A3, #1
	LSL A3, A3, V1
	ANDS A4, A1, A3
	BEQ skip_flooding
	
	CMP V1, #4
	BLT fld_hex0_3

fld_hex4_5:
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_flood_store

fld_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1
do_flood_store:
	MOV A2, #0xFF
	STRB A2, [A3]
skip_flooding:
	ADD V1, V1, #1
	CMP V1, #6
	BLT loop_fld
	
	POP {V1,V2,PC}





HEX_write_ASM:
	PUSH {V1,V2,LR} 
	LDR A3, =HEX_CODES
	
	
	ADD A3, A3, A2
	LDRB A4, [A3]
	MOV V1, #0 //i


loop_write:
	MOV A3, #1
	LSL A3, A3, V1
	TST A1, A3
	BEQ skip_writing 
	CMP V1, #4
	BLT write_hex0_3

write_hex4_5:
	LDR V2, =HEX_BASE_ADDR_4_5
	SUB A3, V1, #4
	ADD A3, V2, A3
	B do_write_store


write_hex0_3: 
	LDR V2, =HEX_BASE_ADDR
	ADD A3, V2, V1
do_write_store:
	STRB A4, [A3]

skip_writing:
	ADD V1, V1, #1
	CMP V1, #6
	BLT loop_write
	POP {V1,V2, PC}









read_slider_switches_ASM:
    LDR A2, =SW_ADDR
    LDR A1, [A2]
    BX LR
write_LEDs_ASM:
    LDR A2, =LED_ADDR
    STR A1, [A2]
    BX LR
_start:
    /* Set up stack pointers for IRQ and SVC processor modes */
	MOV R1, #0b11010010     // interrupts masked, MODE = IRQ
	MSR CPSR_c, R1          // change to IRQ mode
	LDR SP, =0xFFFFFFFF - 3 // set IRQ stack to A9 on-chip memory
	/* Change to SVC (supervisor) mode with interrupts disabled */
	MOV R1, #0b11010011     // interrupts masked, MODE = SVC
	MSR CPSR, R1            // change to supervisor mode
	LDR SP, =0x3FFFFFFF - 3 // set SVC stack to top of DDR3 memory

    // STEP 1: Configure the interrupt controller for both sources
	BL CONFIG_GIC       
    
    // STEP 2: Configure the peripherals themselves
    // Enable interrupts for all 4 pushbuttons
    MOV A1, #0xF            
    BL enable_PB_INT_ASM
    
    // Configure and start the ARM Timer for 0.25 seconds
    LDR A1, =50000000       // Load value for 0.25s (200MHz * 0.25)
    MOV A2, #0b111          // E=1 (enable), A=1 (autoreload), I=1 (interrupt)
    BL ARM_TIM_config_ASM

    // STEP 3: Enable interrupts in the ARM processor itself (the final step)
    MOV R0, #0b01010011     // IRQ unmasked, MODE = SVC
    MSR CPSR_c, R0      

//=============================================================================
// MAIN APPLICATION LOOP
//=============================================================================
IDLE:
    // 1. Poll Inputs: Check the slider switches for message changes.
    BL  handle_slider_switches

    // 2. Check for Events: Has a timer interrupt occurred?
    BL  handle_timer_interrupt

    // 3. Check for Events: Has a pushbutton interrupt occurred?
    BL  handle_pushbutton_interrupt

    // 4. Update Outputs: Redraw the HEX displays and LEDs.
    BL  update_display

    B   IDLE

//=============================================================================
// SUBROUTINE: handle_slider_switches
// Checks if the switch state has changed and updates the current message
// accordingly. Resets display offset when the message changes.
//=============================================================================
handle_slider_switches:
    PUSH {R0-R5, LR}
    
    BL read_slider_switches_ASM     // A1 now holds the current switch state
    MOV R0, A1                      // Move switch state to R0 for processing

    LDR R1, =previous_switch_state
    LDR R2, [R1]                    // R2 = previous switch state
    CMP R0, R2                      // Has the switch state changed?
    BEQ SWITCH_NO_CHANGE            // If not, we are done here.

    STR R0, [R1]                    // It changed, so update the previous state

    // Determine which message to load based on the new switch state
    MOV R3, #0
    CMP R0, #0x01
    LDREQ R3, =MSG_CAFE5
    CMP R0, #0x02
    LDREQ R3, =MSG_CAb5
    CMP R0, #0x04
    LDREQ R3, =MSG_ACE
    CMP R0, #0x08
    LDREQ R3, =MSG_70Ad
    CMP R0, #0x10
    LDREQ R3, =MSG_CAFEbEEF
    CMP R0, #0x00
    LDREQ R3, =MSG_C0FFEE

    // If R3 is still 0, it was an invalid combo
    CMP R3, #0
    LDREQ R3, =BLANK_MSG

    // We have a new message (or a blank one), so update the state
    LDR R4, =current_message_ptr
    STR R3, [R4]                    // Store the address of the new message

    LDR R4, =display_offset
    MOV R5, #0
    STR R5, [R4]                    // Reset the display offset to 0

SWITCH_NO_CHANGE:
    POP {R0-R5, PC}

//=============================================================================
// SUBROUTINE: handle_timer_interrupt
// Checks the timer flag. If set, it updates the display offset to rotate
// the message, handling wrap-around.
//=============================================================================
handle_timer_interrupt:
    PUSH {R0-R6, LR}

    LDR R0, =tim_int_flag
    LDR R1, [R0]
    CMP R1, #0
    BEQ TIMER_DONE              // If flag is 0, do nothing

    MOV R2, #0
    STR R2, [R0]                // Reset the flag to 0

    LDR R3, =is_paused
    LDR R3, [R3]
    CMP R3, #1
    BEQ TIMER_DONE              // If paused, do nothing more

    // --- New Wrap-Around Logic ---
    LDR R4, =current_message_ptr
    LDR R4, [R4]                // R4 = base address of the current message

    // 1. Find the length of the message
    MOV R5, #0                  // R5 = message_length
MSG_LEN_LOOP:
    LDRB R6, [R4, R5]
    CMP R6, #255
    BEQ MSG_LEN_FOUND
    ADD R5, R5, #1
    B MSG_LEN_LOOP
MSG_LEN_FOUND:

    // 2. Update the offset
    LDR R0, =display_offset
    LDR R1, [R0]                // R1 = current offset
    LDR R2, =direction
    LDR R2, [R2]                // R2 = direction (1 or -1)
    ADD R1, R1, R2              // Update offset

    // 3. Perform Modulo to wrap around
    // If offset is negative, add length until it's positive
WRAP_NEGATIVE:
    CMP R1, #0
    BGE WRAP_POSITIVE
    ADD R1, R1, R5
    B WRAP_NEGATIVE
    // If offset is >= length, subtract length until it's in range
WRAP_POSITIVE:
    CMP R1, R5
    BLT OFFSET_OK
    SUB R1, R1, R5
    B WRAP_POSITIVE
OFFSET_OK:
    STR R1, [R0]                // Store the final, wrapped offset

TIMER_DONE:
    POP {R0-R6, PC}
TIMER_NO_INT:
    POP {R0-R5, PC}

//=============================================================================
// SUBROUTINE: handle_pushbutton_interrupt
// Checks the PB flag. If set, performs an action (pause, reverse, speed up,
// slow down) based on which button was pressed.
//=============================================================================
handle_pushbutton_interrupt:
    PUSH {R0-R4, LR}
    
    LDR R0, =PB_int_flag
    LDR R1, [R0]                    // R1 = edgecapture value
    CMP R1, #0
    BEQ PB_NO_INT                   // If flag is 0, do nothing

    // Flag was set, so reset it immediately
    MOV R2, #0
    STR R2, [R0]

    // Check which button was pressed using TST
    // PB3 (0x8): Pause/Resume
    TST R1, #0x8
    BNE PB3_PRESSED

    // If not paused, check other buttons
    LDR R3, =is_paused
    LDR R3, [R3]
    CMP R3, #1
    BEQ PB_NO_INT                   // If paused, other buttons do nothing

    // PB2 (0x4): Reverse Direction
    TST R1, #0x4
    BNE PB2_PRESSED
    // PB1 (0x2): Speed Up
    TST R1, #0x2
    BNE PB1_PRESSED
    // PB0 (0x1): Slow Down
    TST R1, #0x1
    BNE PB0_PRESSED

    B PB_NO_INT                     // If no known button, exit

PB3_PRESSED:
    LDR R0, =is_paused
    LDR R1, [R0]
    EOR R1, R1, #1                  // Toggle the pause state (0->1, 1->0)
    STR R1, [R0]
    B PB_NO_INT

PB2_PRESSED:
    LDR R0, =direction
    LDR R1, [R0]
    RSB R1, R1, #0                  // Negate the direction (1 -> -1, -1 -> 1)
    STR R1, [R0]
    B PB_NO_INT

PB1_PRESSED: // Speed Up
    LDR R0, =speed_index
    LDR R1, [R0]
    CMP R1, #4                      // Already at max speed?
    BEQ PB_NO_INT                   // If yes, do nothing
    ADD R1, R1, #1                  // Increment speed index
    STR R1, [R0]
    BL update_timer_speed
    B PB_NO_INT

PB0_PRESSED: // Slow Down
    LDR R0, =speed_index
    LDR R1, [R0]
    CMP R1, #0                      // Already at min speed?
    BEQ PB_NO_INT                   // If yes, do nothing
    SUB R1, R1, #1                  // Decrement speed index
    STR R1, [R0]
    BL update_timer_speed

PB_NO_INT:
    POP {R0-R4, PC}

//=============================================================================
// SUBROUTINE: update_timer_speed
// Helper function. Reads the current speed_index and re-configures the
// ARM timer with the corresponding new load value from SPEED_TABLE.
//=============================================================================
update_timer_speed:
    PUSH {R0-R2, LR}

    LDR R0, =speed_index
    LDR R1, [R0]                    // R1 = current speed index (0-4)
    LDR R0, =SPEED_TABLE
    LDR A1, [R0, R1, LSL #2]        // A1 = SPEED_TABLE[speed_index]

    MOV A2, #0b111                  // Control bits: Enable, Autoreload, Interrupt
    BL ARM_TIM_config_ASM

    POP {R0-R2, PC}

//=============================================================================
// SUBROUTINE: update_display
// The main drawing routine. Reads all state variables and updates the
// HEX displays and LEDs to reflect the current state.
//=============================================================================
update_display:
    PUSH {R0-R8, LR}

    // --- Update LEDs ---
    LDR R0, =is_paused
    LDR R0, [R0]
    CMP R0, #1
    MOVEQ A1, #0                    // If paused, turn all LEDs off
    BEQ WRITE_THE_LEDS
    
    LDR R1, =speed_index
    LDR R1, [R1]
    LDR R0, =LED_TABLE
    LDR A1, [R0, R1, LSL #2]        // Load LED pattern from table

WRITE_THE_LEDS:
    BL write_LEDs_ASM

    // --- Update HEX Displays ---
    LDR R0, =current_message_ptr
    LDR R0, [R0]                    // R0 = pointer to current message string
    LDR R1, =display_offset
    LDR R1, [R1]                    // R1 = current display offset

    MOV R4, #0                      // R4 = loop counter for HEX displays (i=0)
HEX_DISPLAY_LOOP:
    CMP R4, #6
    BGE END_HEX_LOOP

    // Get the character for this HEX display.
    // R2 will hold the final character value (0-15 or 255 for blank)
    ADD R3, R0, R1                  // R3 = message_ptr + offset
    ADD R3, R3, R4                  // R3 = message_ptr + offset + i
    
    // This is a simplified wrap-around. A full implementation is more complex.
    // For now, this will display characters from the message array.
    LDRB R2, [R3] // This needs a proper wrap-around function for long messages.
                  // The logic for that is complex, so let's use a placeholder.
    // This placeholder just reads from memory, you will need to add full
    // wrap-around logic that checks for the 255 byte.

    // A proper get_char_at(pos) would go here.
    // For now, we'll proceed with this simplified version.

    MOV A2, R2                      // A2 = character to display
    MOV R5, #1
    LSL A1, R5, R4                  // A1 = HEX display index (1, 2, 4, 8...)

    CMP A2, #255
    BLEQ HEX_clear_ASM              // If char is 255, clear the display
    BLNE HEX_write_ASM              // Otherwise, write the character

    ADD R4, R4, #1
    B HEX_DISPLAY_LOOP

END_HEX_LOOP:
    POP {R0-R8, PC}
CONFIG_GIC:
	PUSH {LR}
/* To configure the FPGA KEYS interrupt (ID 73):
* 1. set the target to cpu0 in the ICDIPTRn register
* 2. enable the interrupt in the ICDISERn register */
/* CONFIG_INTERRUPT (int_ID (R0), CPU_target (R1)); */
/* NOTE: you can configure different interrupts
	by passing their IDs to R0 and repeating the next 3 lines */
	MOV R0, #73 // KEY port (Interrupt ID = 73)
	MOV R1, #1 // this field is a bit-mask; bit 0 targets cpu0
	BL CONFIG_INTERRUPT
	
	
// Configure ARM A9 Private Timer Interrupt (ID 29)
    MOV R0, #29
    MOV R1, #1                  // Target cpu0
    BL CONFIG_INTERRUPT

/* configure the GIC CPU Interface */
	LDR R0, =0xFFFEC100 // base address of CPU Interface
/* Set Interrupt Priority Mask Register (ICCPMR) */
	LDR R1, =0xFFFF // enable interrupts of all priorities levels
	STR R1, [R0, #0x04]
/* Set the enable bit in the CPU Interface Control Register (ICCICR).
* This allows interrupts to be forwarded to the CPU(s) */
	MOV R1, #1
	STR R1, [R0]
/* Set the enable bit in the Distributor Control Register (ICDDCR).
* This enables forwarding of interrupts to the CPU Interface(s) */
	LDR R0, =0xFFFED000
	STR R1, [R0]
	POP {PC}


/*
* Configure registers in the GIC for an individual Interrupt ID
* We configure only the Interrupt Set Enable Registers (ICDISERn) and
* Interrupt Processor Target Registers (ICDIPTRn). The default (reset)
* values are used for other registers in the GIC
* Arguments: R0 = Interrupt ID, N
* R1 = CPU target
*/
CONFIG_INTERRUPT:
	PUSH {R4-R5, LR}
/* Configure Interrupt Set-Enable Registers (ICDISERn).
* reg_offset = (integer_div(N / 32) * 4
* value = 1 << (N mod 32) */
	LSR R4, R0, #3 // calculate reg_offset
	BIC R4, R4, #3 // R4 = reg_offset
	LDR R2, =0xFFFED100
	ADD R4, R2, R4 // R4 = address of ICDISER
	AND R2, R0, #0x1F // N mod 32
	MOV R5, #1 // enable
	LSL R2, R5, R2 // R2 = value
/* Using the register address in R4 and the value in R2 set the
* correct bit in the GIC register */
	LDR R3, [R4] // read current register value
	ORR R3, R3, R2 // set the enable bit
	STR R3, [R4] // store the new register value
/* Configure Interrupt Processor Targets Register (ICDIPTRn)
* reg_offset = integer_div(N / 4) * 4
* index = N mod 4 */
	BIC R4, R0, #3 // R4 = reg_offset
	LDR R2, =0xFFFED800
	ADD R4, R2, R4 // R4 = word address of ICDIPTR
	AND R2, R0, #0x3 // N mod 4
	ADD R4, R2, R4 // R4 = byte address in ICDIPTR
/* Using register address in R4 and the value in R2 write to
* (only) the appropriate byte */
	STRB R1, [R4]
	POP {R4-R5, PC}


	
	
/*--- Undefined instructions --------------------------------------*/
SERVICE_UND:
	B SERVICE_UND
/*--- Software interrupts ----------------------------------------*/
SERVICE_SVC:
	B SERVICE_SVC
/*--- Aborted data reads ------------------------------------------*/
SERVICE_ABT_DATA:
	B SERVICE_ABT_DATA
/*--- Aborted instruction fetch -----------------------------------*/
SERVICE_ABT_INST:
	B SERVICE_ABT_INST
/*--- IRQ ---------------------------------------------------------*/

/*--- FIQ ---------------------------------------------------------*/
SERVICE_IRQ:
    PUSH {R0-R7, LR}
    
    LDR R4, =0xFFFEC100         // GIC CPU interface base address
    LDR R5, [R4, #0x0C]         // Read the Interrupt ID from the ICCIAR register

CHECK_TIMER_INT:
    CMP R5, #29                 // Is the Interrupt ID 29 (ARM A9 Private Timer)?
    BLEQ ARM_TIM_ISR            // If yes, branch to the Timer ISR
    
CHECK_PB_INT:
    CMP R5, #73                 // Is the Interrupt ID 73 (Pushbuttons)?
    BLEQ KEY_ISR                // If yes, branch to the Pushbutton ISR

UNEXPECTED:                     // If the ID is not 29 or 73, something is wrong
    // For debugging, you could loop here. In the final code, just exit.

EXIT_IRQ:
    STR R5, [R4, #0x10]         // Write to End of Interrupt Register (ICCEOIR)
    POP {R0-R7, LR}
    SUBS PC, LR, #4
   
   
   
KEY_ISR:
    PUSH {R2, R3, LR}           // <--- FIX: Save the Link Register

    LDR R2, =PB_EDGECP_ADDR
    LDR R3, [R2]

    LDR R2, =PB_int_flag
    STR R3, [R2]

    LDR R2, =PB_EDGECP_ADDR
    STR R3, [R2]

    POP {R2, R3, PC}            // <--- FIX: Pop into the Program Counter
   
   
  
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   






//part 2:




